<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-t" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DATABEND - Obscure Edition (Normalized)</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      html,
      body {
        height: 100%;
        background: #121212;
        color: #e0e0e0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      :root {
        --accent: #0d7377;
        --muted: #242424;
      }
      .app {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr 40px;
        gap: 0;
      }

      /* Header */
      .header {
        background: #1a1a1a;
        border-bottom: 1px solid #333;
        padding: 12px 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .logo {
        font-size: 18px;
        font-weight: 600;
        letter-spacing: 1px;
      }
      .header-center {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .header-center .btn {
        padding: 8px 14px;
        font-size: 12px;
        font-weight: 600;
        border-radius: 4px;
        cursor: pointer;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        background: var(--accent);
        border: none;
        color: #fff;
      }
      .header-center .btn.secondary {
        background: #424242;
        color: #e0e0e0;
      }
      .header-center .btn.secondary:hover {
        background: #505050;
      }
      .header-center .btn:hover {
        background: #14a085;
      }
      .header-right {
        display: flex;
        gap: 16px;
        align-items: center;
        font-size: 12px;
        color: #888;
      }

      /* Main layout - Waveform view is now larger */
      .main {
        display: grid;
        grid-template-columns: 1fr;
        overflow: hidden;
      }
      .canvas-area {
        background: #0a0a0a;
        position: relative;
        overflow: hidden;
        border-right: none;
      }
      /* hide original side panel; keep buttons in DOM for delegation */
      .panel {
        display: none;
      }

      /* processors popup */
      #procMenu {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%) scale(0.98);
        width: min(780px, 92vw);
        max-height: 80vh;
        overflow: auto;
        background: #151515;
        border: 1px solid #333;
        border-radius: 10px;
        padding: 18px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
        z-index: 120;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.16s ease, transform 0.16s ease;
      }
      #procMenu.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: auto;
      }
      #procMenu .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 10px;
      }
      #procMenu .proc-btn {
        padding: 10px 12px;
        background: #202020;
        border: 1px solid #333;
        color: #e6f9f7;
        font-weight: 700;
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
      }
      #procMenu .proc-btn:hover {
        background: #262626;
        transform: translateY(-1px);
      }

      #canvas,
      #overlay {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
        position: absolute;
        top: 0;
        left: 0;
      }

      /* Panel */
      .panel {
        background: #1a1a1a;
        border-left: 1px solid #333;
        display: grid;
        grid-template-rows: auto 1fr auto;
        overflow: hidden;
        min-width: 320px;
      }
      .panel-header {
        padding: 16px;
        border-bottom: 1px solid #333;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #999;
      }
      .panel-content {
        overflow-y: auto;
        padding: 16px;
      }
      .panel-content::-webkit-scrollbar {
        width: 6px;
      }
      .panel-content::-webkit-scrollbar-thumb {
        background: #333;
        border-radius: 3px;
      }
      .section {
        margin-bottom: 20px;
      }
      .section-title {
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #999;
        margin-bottom: 10px;
      }
      .btn {
        padding: 10px 14px;
        background: var(--accent);
        border: none;
        color: #fff;
        font-size: 12px;
        font-weight: 600;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .btn:hover {
        background: #14a085;
      }
      .btn-secondary {
        background: #424242;
      }
      .btn-secondary:hover {
        background: #505050;
      }
      .btn-danger {
        background: #d32f2f;
      }
      .btn-danger:hover {
        background: #f32c1e;
      }
      .btn-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
      }
      .control-label {
        font-size: 11px;
        color: #999;
        margin-bottom: 6px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: block;
      }
      input[type="range"] {
        width: 100%;
        height: 4px;
        background: #2a2a2a;
        border: none;
        border-radius: 2px;
        -webkit-appearance: none;
        cursor: pointer;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
      }
      input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }
      input[type="number"],
      select,
      input[type="text"] {
        width: 100%;
        padding: 8px;
        background: #242424;
        border: 1px solid #333;
        color: #e0e0e0;
        font-size: 12px;
        border-radius: 4px;
      }
      .display {
        background: var(--muted);
        border: 1px solid #333;
        padding: 8px;
        border-radius: 4px;
        font-size: 11px;
        color: #aaa;
        font-family: monospace;
      }
      .note {
        font-size: 11px;
        color: #888;
        margin-top: 8px;
      }

      /* Progress bar */
      #glitchProgressWrap {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 12px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        z-index: 40;
      }
      #glitchProgress {
        pointer-events: auto;
        width: 94%;
        max-width: 1000px;
        height: 46px;
        background: rgba(13, 115, 119, 0.08);
        border: 2px solid rgba(13, 115, 119, 0.35);
        border-radius: 8px;
        padding: 10px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        overflow: hidden;
        opacity: 0;
        transform: translateY(16px) scale(0.96);
        transition: opacity 0.22s ease,
          transform 0.28s cubic-bezier(0.2, 0.9, 0.3, 1);
        color: #cfeeea;
        position: relative;
        font-family: "Courier New", monospace;
      }
      #glitchProgress.show {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      .progress-bar-fill {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        background: linear-gradient(
          90deg,
          rgba(13, 115, 119, 0.9),
          rgba(13, 115, 119, 0.6)
        );
        width: 0%;
        transition: width 0.15s ease-out;
      }
      .progress-bar-text {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-weight: 700;
        color: #e6f9f7;
        text-shadow: 0 0 4px rgba(13, 115, 119, 0.8);
      }
      .footer {
        background: #1a1a1a;
        border-top: 1px solid #333;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 24px;
        font-size: 11px;
        color: #666;
      }

      /* Modal Styles */
      #modalOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 100;
        display: none;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      #modalOverlay.show {
        display: flex;
        opacity: 1;
      }
      #modalDialog {
        background: #1e1e1e;
        border: 1px solid #333;
        border-radius: 8px;
        width: 90%;
        max-width: 400px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        transform: scale(0.95);
        transition: transform 0.2s ease;
      }
      #modalOverlay.show #modalDialog {
        transform: scale(1);
      }
      #modalHeader {
        padding: 14px 20px;
        border-bottom: 1px solid #333;
      }
      #modalTitle {
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }
      #modalContent {
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      #modalFooter {
        padding: 14px 20px;
        border-top: 1px solid #333;
        display: flex;
        gap: 8px;
        justify-content: flex-end;
      }
      .modal-control {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .modal-control .control-label {
        display: flex;
        justify-content: space-between;
      }
      .modal-control .control-label .value-display {
        color: #e0e0e0;
        font-weight: 600;
      }

      /* ======= Responsive Mobile Styles ======= */
      @media (max-width: 768px) {
        .app {
          grid-template-rows: auto 1fr 40px;
        }
        .main {
          grid-template-columns: 1fr;
          grid-template-rows: minmax(200px, 1fr) auto;
          overflow-y: auto;
        }
        .panel {
          border-left: none;
          border-top: 1px solid #333;
          grid-template-rows: auto 1fr;
          min-height: 450px;
        }
        .canvas-area {
          border-right: none;
          min-height: 200px;
        }
        .header {
          flex-wrap: wrap;
          padding: 12px;
          height: auto;
          gap: 12px;
          justify-content: center;
        }
        .header-center {
          order: 2;
          width: 100%;
          justify-content: center;
        }
        .logo {
          order: 1;
          flex-basis: 50%;
        }
        .header-right {
          order: 3;
          flex-basis: 50%;
          text-align: right;
        }
        #modalDialog {
          width: 95%;
        }
        .footer {
          padding: 0 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="header">
        <div class="logo">DATABEND</div>
        <div class="header-center">
          <button class="btn" id="playBtn">Play</button>
          <button class="btn secondary" id="stopBtn">Stop</button>
          <button class="btn secondary" id="exportBtn">Export</button>

          <!-- non-processor controls moved to top -->
          <button
            class="btn secondary"
            id="loadBtn"
            style="
              background: #2e6f72;
              padding: 6px 10px;
              font-weight: 700;
              margin-left: 6px;
            "
          >
            Load
          </button>
          <button
            class="btn secondary"
            id="duplicateBtn"
            style="padding: 6px 10px; margin-left: 6px"
          >
            Duplicate
          </button>
          <button
            class="btn btn-danger"
            id="deleteBtn"
            style="padding: 6px 10px; margin-left: 6px"
          >
            Delete
          </button>
          <button
            class="btn secondary"
            id="undoBtn"
            style="padding: 6px 10px; margin-left: 6px"
          >
            Undo
          </button>
          <button
            class="btn secondary"
            id="redoBtn"
            style="padding: 6px 10px; margin-left: 6px"
          >
            Redo
          </button>

          <!-- NOTE: intensity & chunk are context controls and are shown in the Processors popup -->
          <!-- (kept out of the main header to avoid confusion) -->
        </div>
        <div class="header-right"><span id="status">Ready</span></div>
      </div>

      <div class="main">
        <div class="canvas-area">
          <canvas id="canvas"></canvas>
          <canvas id="overlay"></canvas>
          <div id="glitchProgressWrap">
            <div id="glitchProgress">
              <div class="progress-bar-fill" id="progressBarFill"></div>
              <div class="progress-bar-text" id="progressBarText">0%</div>
            </div>
          </div>
        </div>

        <!-- Keep original processor buttons hidden so existing JS handlers (bitcrushBtn, foldBtn, etc.) work -->
        <div class="panel" aria-hidden="true" style="display: none">
          <div class="panel-content" style="padding: 8px">
            <button id="bitcrushBtn"></button>
            <button id="foldBtn"></button>
            <button id="shiftBtn"></button>
            <button id="invertBtn"></button>
            <button id="randomBtn"></button>
            <button id="corruptBtn"></button>
            <button id="granularBtn"></button>
            <button id="stutterBtn"></button>
            <button id="reverseBtn"></button>
            <button id="scrambleBtn"></button>
            <button id="ringBtn"></button>
            <button id="warpBtn"></button>
            <button id="smearBtn"></button>
            <button id="chebyBtn"></button>
            <button id="combBtn"></button>
            <button id="tapeStopBtn"></button>
            <button id="melterBtn"></button>
            <button id="shredderBtn"></button>
            <button id="bitScrambleBtn"></button>
            <button id="filterBtn"></button>
            <button id="phaserBtn"></button>
            <button id="delayBtn"></button>
            <button id="reverbBtn"></button>
            <!-- NEW WAVELET BUTTONS -->
            <button id="waveletChaosBtn"></button>
            <button id="scaleCorruptorBtn"></button>
            <button id="waveletTreeDisruptorBtn"></button>
            <button id="entropyGlitchBtn"></button>
          </div>
        </div>

        <!-- processor popup -->
        <div id="procMenu" aria-hidden="true">
          <div
            style="
              display: flex;
              gap: 8px;
              align-items: center;
              justify-content: space-between;
              margin-bottom: 12px;
            "
          >
            <div style="font-weight: 700; color: #cfeeea">Processors</div>
            <button id="procClose" class="btn secondary" style="height: 36px">
              Close
            </button>
          </div>

          <!-- Shared contextual controls: these only apply to some processors.
               Keeping the inputs here clarifies scope while preserving existing IDs
               so processor code can continue reading document.getElementById('...').value -->
          <div
            style="
              display: flex;
              gap: 12px;
              align-items: center;
              margin-bottom: 12px;
              flex-wrap: wrap;
            "
          >
            <label
              style="
                font-size: 12px;
                color: #cfeeea;
                display: flex;
                gap: 8px;
                align-items: center;
              "
            >
              Intensity
              <input
                id="intensity"
                type="range"
                min="0"
                max="100"
                value="50"
                style="width: 160px"
              />
            </label>
            <label
              style="
                font-size: 12px;
                color: #cfeeea;
                display: flex;
                gap: 8px;
                align-items: center;
              "
            >
              Chunk
              <input
                id="chunkSize"
                type="range"
                min="4"
                max="4096"
                step="4"
                value="512"
                style="width: 160px"
              />
              <span
                id="chunkVal"
                style="
                  min-width: 48px;
                  text-align: center;
                  font-weight: 700;
                  color: #cfeeea;
                "
                >512</span
              >
            </label>
            <div
              style="
                font-size: 11px;
                color: #9aa;
                margin-left: 6px;
                max-width: 40ch;
              "
            >
              These shared controls apply only to some processors (e.g.
              Intensity → Shift / Invert / Random / Corrupt; Chunk → Granular /
              Stutter / Scramble). Per-processor modals may expose additional
              parameters.
            </div>
          </div>

          <div class="grid">
            <!-- each button delegates to the hidden panel button by data-target -->
            <button class="proc-btn" data-target="bitcrushBtn">BitCrush</button>
            <button class="proc-btn" data-target="foldBtn">Fold</button>
            <button class="proc-btn" data-target="shiftBtn">Shift</button>
            <button class="proc-btn" data-target="invertBtn">Invert</button>
            <button class="proc-btn" data-target="randomBtn">Random</button>
            <button class="proc-btn" data-target="corruptBtn">Corrupt</button>
            <button class="proc-btn" data-target="granularBtn">Granular</button>
            <button class="proc-btn" data-target="stutterBtn">Stutter</button>
            <button class="proc-btn" data-target="reverseBtn">Reverse</button>
            <button class="proc-btn" data-target="scrambleBtn">Scramble</button>
            <button class="proc-btn" data-target="ringBtn">Ring Mod</button>
            <button class="proc-btn" data-target="warpBtn">Bit Warp</button>
            <button
              class="proc-btn"
              data-target="smearBtn"
              style="grid-column: span 2"
            >
              Spectral Smear
            </button>
            <button class="proc-btn" data-target="chebyBtn">Chebyshev</button>
            <button class="proc-btn" data-target="combBtn">Feedback</button>
            <button class="proc-btn" data-target="tapeStopBtn">
              Tape Stop
            </button>
            <button class="proc-btn" data-target="melterBtn">Melter</button>
            <button class="proc-btn" data-target="shredderBtn">Shredder</button>
            <button class="proc-btn" data-target="bitScrambleBtn">
              Bit Scramble
            </button>
            <button class="proc-btn" data-target="filterBtn">Filter</button>
            <button class="proc-btn" data-target="phaserBtn">Phaser</button>
            <button class="proc-btn" data-target="delayBtn">Delay</button>
            <button class="proc-btn" data-target="reverbBtn">Reverb</button>
            
            <!-- NEW WAVELET PROCESSORS -->
            <button class="proc-btn" data-target="waveletChaosBtn" style="grid-column: span 2; background-color: #2e1a47;">Wavelet Chaos Engine</button>
            <button class="proc-btn" data-target="scaleCorruptorBtn" style="grid-column: span 2; background-color: #2e1a47;">Scale-Subband Corruptor</button>
            <button class="proc-btn" data-target="waveletTreeDisruptorBtn" style="grid-column: span 2; background-color: #2e1a47;">Wavelet Tree Disruptor</button>
            <button class="proc-btn" data-target="entropyGlitchBtn" style="grid-column: span 2; background-color: #2e1a47;">Entropy Glitch Injector</button>
          </div>
        </div>
      </div>
      <div class="footer">
        <div id="fileInfo">No file loaded</div>
        <div>DATABEND - Audio Bender</div>
        <div id="duration">0.00s</div>
      </div>
    </div>

    <div id="modalOverlay">
      <div id="modalDialog">
        <div id="modalHeader"><div id="modalTitle">Process</div></div>
        <div id="modalContent"></div>
        <div id="modalFooter">
          <button class="btn secondary" id="modalCancel">Cancel</button>
          <button class="btn secondary" id="modalRandom">Random</button>
          <button class="btn" id="modalCommit">Commit</button>
        </div>
      </div>
    </div>

    <script>
      /* ======= DOM refs ======= */
      const canvas = document.getElementById("canvas"),
        ctx = canvas.getContext("2d");
      const overlay = document.getElementById("overlay"),
        octx = overlay.getContext("2d");
      const loadBtn = document.getElementById("loadBtn");
      const playBtn = document.getElementById("playBtn");
      const stopBtn = document.getElementById("stopBtn");
      const exportBtn = document.getElementById("exportBtn");
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      const duplicateBtn = document.getElementById("duplicateBtn");
      const deleteBtn = document.getElementById("deleteBtn");
      const bitcrushBtn = document.getElementById("bitcrushBtn");
      const foldBtn = document.getElementById("foldBtn");
      const shiftBtn = document.getElementById("shiftBtn");
      const invertBtn = document.getElementById("invertBtn");
      const randomBtn = document.getElementById("randomBtn");
      const corruptBtn = document.getElementById("corruptBtn");
      const granularBtn = document.getElementById("granularBtn");
      const stutterBtn = document.getElementById("stutterBtn");
      const reverseBtn = document.getElementById("reverseBtn");
      const scrambleBtn = document.getElementById("scrambleBtn");
      const ringBtn = document.getElementById("ringBtn");
      const warpBtn = document.getElementById("warpBtn");
      const smearBtn = document.getElementById("smearBtn");
      const chebyBtn = document.getElementById("chebyBtn");
      const combBtn = document.getElementById("combBtn");
      const filterBtn = document.getElementById("filterBtn");
      const phaserBtn = document.getElementById("phaserBtn");
      const delayBtn = document.getElementById("delayBtn");
      const reverbBtn = document.getElementById("reverbBtn");
      const tapeStopBtn = document.getElementById("tapeStopBtn");
      const melterBtn = document.getElementById("melterBtn");
      const shredderBtn = document.getElementById("shredderBtn");
      const bitScrambleBtn = document.getElementById("bitScrambleBtn");
      // New wavelet buttons
      const waveletChaosBtn = document.getElementById("waveletChaosBtn");
      const scaleCorruptorBtn = document.getElementById("scaleCorruptorBtn");
      const waveletTreeDisruptorBtn = document.getElementById("waveletTreeDisruptorBtn");
      const entropyGlitchBtn = document.getElementById("entropyGlitchBtn");

      const intensityEl = document.getElementById("intensity");
      const chunkSizeEl = document.getElementById("chunkSize");
      const chunkValEl = document.getElementById("chunkVal");
      // keep the chunk number in sync with the fader
      if (chunkSizeEl && chunkValEl) {
        chunkValEl.textContent = chunkSizeEl.value;
        chunkSizeEl.addEventListener("input", () => {
          chunkValEl.textContent = chunkSizeEl.value;
        });
      }
      const statusEl = document.getElementById("status");
      const fileInfoEl = document.getElementById("fileInfo");
      const durationEl = document.getElementById("duration");
      const glitchBox = document.getElementById("glitchProgress");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressBarText = document.getElementById("progressBarText");
      const modalOverlay = document.getElementById("modalOverlay");
      const modalTitle = document.getElementById("modalTitle");
      const modalContent = document.getElementById("modalContent");
      const modalCommit = document.getElementById("modalCommit");
      const modalRandom = document.getElementById("modalRandom");
      const modalCancel = document.getElementById("modalCancel");

      /* ======= Audio / State ======= */
      let audioCtx = null;
      let current = null,
        history = [],
        historyIndex = -1;
      let playing = false,
        playSource = null,
        playStartTime = 0,
        playOffset = 0,
        playLoopActive = false;
      let loopStart = 0,
        loopEnd = 0;
      const accent =
        getComputedStyle(document.documentElement).getPropertyValue(
          "--accent"
        ) || "#0d7377";

      /* ======= IndexedDB Logic ======= */
      const DB_NAME = "databendDB",
        STORE_NAME = "audioStore";
      let db;
      async function openDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, 1);
          request.onerror = () => reject("Error opening DB");
          request.onsuccess = (e) => {
            db = e.target.result;
            resolve(db);
          };
          request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME))
              db.createObjectStore(STORE_NAME);
          };
        });
      }
      async function saveAudioToDB(float32Array) {
        if (!db) await openDB();
        const tx = db.transaction([STORE_NAME], "readwrite");
        return tx.objectStore(STORE_NAME).put(float32Array, "lastAudioBuffer");
      }
      async function loadAudioFromDB() {
        if (!db) await openDB();
        const tx = db.transaction([STORE_NAME], "readonly");
        return new Promise((res) => {
          const req = tx.objectStore(STORE_NAME).get("lastAudioBuffer");
          req.onsuccess = () => res(req.result);
          req.onerror = () => res(null);
        });
      }

      /* ======= Init ======= */
      async function init() {
        // Initialize AudioContext on first user interaction
        document.addEventListener("click", initAudioContext, { once: true });

        resizeCanvases();
        window.addEventListener("resize", resizeCanvases);
        requestAnimationFrame(drawLoop);
        setupOverlayInteraction();
        setupModal();
        setupProcessorsPopup();

        try {
          setStatus("Checking for saved audio...");
          const savedAudio = await loadAudioFromDB();
          if (savedAudio && savedAudio.length > 0) {
            current = savedAudio;
            history = [savedAudio.slice()];
            historyIndex = 0;
            updateUI();
            setStatus("Restored previous audio", 1200);
          } else {
            setStatus("Ready - Load an audio file to begin");
          }
        } catch (err) {
          console.error("Could not load from DB:", err);
          setStatus("Ready - Load an audio file to begin");
        }
      }

      /**
       * NEW: Sets up a one-time event listener to resume the AudioContext on the next user interaction.
       * This is crucial for mobile devices where the context can be suspended automatically.
       */
      function armAudioResume() {
        const resumeHandler = async () => {
          if (audioCtx && audioCtx.state === "suspended") {
            try {
              await audioCtx.resume();
            } catch (e) {
              console.error("Error resuming AudioContext:", e);
            }
          }
        };
        // Use capture to ensure this fires first, and once to automatically remove the listener.
        document.body.addEventListener("click", resumeHandler, {
          once: true,
          capture: true,
        });
        document.body.addEventListener("touchend", resumeHandler, {
          once: true,
          capture: true,
        });
      }

      /**
       * MODIFIED: Now includes a statechange listener to detect and handle audio interruptions.
       */
      function initAudioContext() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          console.log(
            "AudioContext initialized, sample rate:",
            audioCtx.sampleRate
          );

          // Listen for state changes (e.g., when headphones are unplugged)
          audioCtx.addEventListener("statechange", () => {
            console.log("AudioContext state is now:", audioCtx.state);
            if (audioCtx.state === "suspended") {
              setStatus("Audio paused. Interact to resume.", 0); // Persistent message
              armAudioResume();
            } else if (audioCtx.state === "running") {
              // Clear the "paused" message if it's showing
              if (statusEl.textContent.startsWith("Audio paused")) {
                setStatus("Audio resumed", 1200);
              }
            }
          });
        }

        // This initial resume attempt is still important
        if (audioCtx.state === "suspended") {
          audioCtx.resume().then(() => {
            console.log("AudioContext resumed on initial load");
          });
        }
      }

      init();

      /* ======= Canvas & UI Helpers ======= */
      function resizeCanvases() {
        [ctx, octx].forEach((c) => {
          const canvasEl = c.canvas;
          c.setTransform(1, 0, 0, 1, 0, 0);
          canvasEl.width = canvasEl.offsetWidth * devicePixelRatio;
          canvasEl.height = canvasEl.offsetHeight * devicePixelRatio;
          c.scale(devicePixelRatio, devicePixelRatio);
        });
      }
      function setStatus(text, ms = 1200) {
        statusEl.textContent = text;
        if (ms > 0) {
          clearTimeout(setStatus._t);
          setStatus._t = setTimeout(() => {
            if (statusEl.textContent === text) statusEl.textContent = "Ready";
          }, ms);
        }
      }

      /* ======= File Loading ======= */
      loadBtn.onclick = () => {
        initAudioContext();
        const inp = document.createElement("input");
        inp.type = "file";
        inp.accept =
          "audio/*,audio/wav,audio/mp3,audio/ogg,audio/mpeg,audio/aac,audio/flac";
        inp.multiple = false;

        inp.onchange = async (e) => {
          const file = e.target.files[0];
          if (!file) {
            setStatus("No file selected", 800);
            return;
          }
          setStatus("Loading " + file.name + "...");

          try {
            if (!audioCtx) initAudioContext();
            if (audioCtx.state === "suspended") await audioCtx.resume();

            const ab = await file.arrayBuffer();
            const decoded = await audioCtx.decodeAudioData(ab);

            const len = decoded.length;
            const samp = new Float32Array(len);

            if (decoded.numberOfChannels === 1) {
              samp.set(decoded.getChannelData(0));
            } else {
              const L = decoded.getChannelData(0),
                R = decoded.getChannelData(1);
              for (let i = 0; i < len; i++) samp[i] = (L[i] + R[i]) * 0.5;
            }

            current = samp;
            history = [];
            historyIndex = -1;
            loopStart = 0;
            loopEnd = 0;
            updateUI();
            await saveState();
            setStatus("Loaded: " + file.name, 2000);
          } catch (err) {
            console.error("Error loading file:", err);
            setStatus("Error: " + err.message, 3000);
            alert(
              "Error loading file: " +
                err.message +
                "\n\nPlease check the browser console (F12) for more details."
            );
          }
        };

        try {
          inp.click();
        } catch (err) {
          console.error("Error opening file picker:", err);
          alert("Could not open file picker. Please try again.");
        }
      };

      /* ======= History & State ======= */
      async function saveState() {
        if (!current) return;
        history = history.slice(0, historyIndex + 1);
        history.push(current.slice());
        historyIndex++;
        if (history.length > 50) {
          history.shift();
          historyIndex--;
        }
        try {
          await saveAudioToDB(current);
        } catch (err) {
          console.error("Failed to save state:", err);
          setStatus("Save failed", 1000);
        }
      }
      undoBtn.onclick = async () => {
        if (historyIndex > 0) {
          historyIndex--;
          current = history[historyIndex].slice();
          updateUI();
          setStatus("Undo");
          await saveAudioToDB(current);
        } else setStatus("Nothing to undo", 600);
      };
      redoBtn.onclick = async () => {
        if (historyIndex < history.length - 1) {
          historyIndex++;
          current = history[historyIndex].slice();
          updateUI();
          setStatus("Redo");
          await saveAudioToDB(current);
        } else setStatus("Nothing to redo", 600);
      };

      /* ======= Progress UI & Conversion Functions ======= */
      let progressState = { fraction: 0, label: "" };
      function renderProgress() {
        const percent = Math.round((progressState.fraction || 0) * 100);
        progressBarFill.style.width = percent + "%";
        progressBarText.textContent = percent + "%";
      }
      function glitchProgressStart(label = "Processing...", duration = 900) {
        progressState.label = label;
        progressState.fraction = 0;
        glitchBox.classList.add("show");
        renderProgress();
        const start = performance.now();
        function tick(now) {
          const t = now - start;
          const frac = Math.min(1, t / duration);
          progressState.fraction = frac;
          renderProgress();
          if (frac < 1) requestAnimationFrame(tick);
          else
            setTimeout(() => {
              glitchBox.classList.remove("show");
            }, 120);
        }
        requestAnimationFrame(tick);
      }
      function f32ToInt16Buffer(float32) {
        const buf = new ArrayBuffer(float32.length * 2);
        const dv = new DataView(buf);
        for (let i = 0, o = 0; i < float32.length; i++, o += 2) {
          let v = Math.max(-1, Math.min(1, float32[i]));
          dv.setInt16(o, v < 0 ? v * 0x8000 : v * 0x7fff, true);
        }
        return buf;
      }
      function int16BufferToF32(buf) {
        const dv = new DataView(buf);
        const len = dv.byteLength / 2;
        const out = new Float32Array(len);
        for (let i = 0, o = 0; i < len; i++, o += 2) {
          out[i] = dv.getInt16(o, true) / 0x7fff;
        }
        return out;
      }

      /* ======= Core Processing Logic ======= */
      function applybend(fn, opts) {
        if (!current) {
          setStatus("Load a file first", 800);
          return;
        }
        if (!audioCtx) initAudioContext();
        if (playing) stopPlaybackSilent();

        const sr = audioCtx.sampleRate;
        const hasLoop = loopEnd > loopStart && loopEnd - loopStart > 0.02;
        const startSample = hasLoop ? Math.floor(loopStart * sr) : 0;
        const endSample = hasLoop ? Math.floor(loopEnd * sr) : current.length;

        glitchProgressStart(
          opts.label || "Processing...",
          opts.duration || 900
        );

        setTimeout(async () => {
          try {
            await saveState();
            const region = current.slice(startSample, endSample);

            let oldPeak = 0;
            for (let i = 0; i < region.length; i++) {
              const a = Math.abs(region[i]);
              if (a > oldPeak) oldPeak = a;
            }
            oldPeak = Math.max(oldPeak, 1e-6);

            const processed = fn(region, { ...opts, sr });

            let newPeak = 0;
            for (let i = 0; i < processed.length; i++) {
              const a = Math.abs(processed[i]);
              if (a > newPeak) newPeak = a;
            }
            newPeak = Math.max(newPeak, 1e-6);

            const scale = oldPeak / newPeak;
            if (isFinite(scale) && Math.abs(scale - 1) > 0.001 && scale > 0) {
              for (let i = 0; i < processed.length; i++) processed[i] *= scale;
            }
            for (let i = 0; i < processed.length; i++)
              processed[i] = Math.max(-1.0, Math.min(1.0, processed[i]));

            current.set(processed, startSample);
            updateUI();
            await saveAudioToDB(current);
            setStatus("Processed", 900);
          } catch (err) {
            console.error("applybend err", err);
            setStatus("Error", 1200);
          }
        }, 50);
      }

      /* ======= Modal Logic ======= */
      let currentModal = { controls: {}, callback: null };
      function setupModal() {
        modalCancel.onclick = hideModal;
        modalOverlay.onclick = (e) => {
          if (e.target === modalOverlay) hideModal();
        };
        modalCommit.onclick = () => {
          if (currentModal.callback) {
            const values = {};
            for (const key in currentModal.controls) {
              const id = `modal-control-${key}`;
              const input = document.getElementById(id);
              if(input) {
                if (input.type === 'range') {
                   values[key] = parseFloat(input.value);
                } else if (input.tagName === 'SELECT') {
                   values[key] = input.value;
                }
              }
            }
            currentModal.callback(values);
          }
          hideModal();
        };
        modalRandom.onclick = () => {
          for (const key in currentModal.controls) {
            const c = currentModal.controls[key];
            const id = `modal-control-${key}`;
            const input = document.getElementById(id);
            const valueDisplay = document.getElementById(`${id}-value`);
            if (input && input.type === 'range') {
              const min = parseFloat(c.min),
                max = parseFloat(c.max),
                step = parseFloat(c.step) || 1;
              const range = (max - min) / step;
              const rVal = min + Math.floor(Math.random() * (range + 1)) * step;
              input.value = rVal;
              if (valueDisplay)
                valueDisplay.textContent = rVal.toFixed(step < 1 ? 2 : 0);
            }
          }
        };
      }
      function showModal(config) {
        if (!current) {
          setStatus("Load a file first", 800);
          return;
        }
        if (!audioCtx) initAudioContext();
        currentModal = config;
        modalTitle.textContent = config.title;
        modalContent.innerHTML = "";
        for (const key in config.controls) {
            const c = config.controls[key];
            const id = `modal-control-${key}`;
            const controlWrapper = document.createElement("div");
            controlWrapper.className = "modal-control";
            let controlHTML = '';
            
            if (c.type === 'select') {
                const options = c.options.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('');
                controlHTML = `<div class="control-label">${c.label}</div><select id="${id}">${options}</select>`;
            } else { // Default to range slider
                const labelHTML = `<div class="control-label">${c.label}<span class="value-display" id="${id}-value">${c.defaultValue}</span></div>`;
                const inputHTML = `<input type="range" id="${id}" min="${c.min}" max="${c.max}" step="${c.step || 1}" value="${c.defaultValue}">`;
                controlHTML = labelHTML + inputHTML;
            }
            
            controlWrapper.innerHTML = controlHTML;
            modalContent.appendChild(controlWrapper);
            
            if (c.type !== 'select') {
                const input = document.getElementById(id),
                vDisplay = document.getElementById(`${id}-value`);
                if(input && vDisplay) {
                    input.oninput = () => {
                        vDisplay.textContent = parseFloat(input.value).toFixed(c.step < 1 ? 2 : 0);
                    };
                }
            }
        }
        modalOverlay.classList.add("show");
      }
      function hideModal() {
        modalOverlay.classList.remove("show");
      }
      
      /* ======= WAVELET IMPLEMENTATION START ======= */
      
      const waveletBases = {
        'haar': {
            dec: [1/Math.sqrt(2), 1/Math.sqrt(2)],
            rec: [1/Math.sqrt(2), 1/Math.sqrt(2)]
        },
        'db4': { // Daubechies 4
            dec: [0.4829629131445341, 0.8365163037378079, 0.2241438680420134, -0.12940952255126034],
            rec: [-0.12940952255126034, -0.2241438680420134, 0.8365163037378079, -0.4829629131445341]
        },
        'db8': { // Daubechies 8
            dec: [0.230377813308895, 0.714846570552915, 0.630880767929859, -0.027983769416859, -0.187034811719093, 0.030841381835561, 0.032883011666885, -0.010597401785069],
            rec: [-0.010597401785069, -0.032883011666885, 0.030841381835561, 0.187034811719093, -0.027983769416859, -0.630880767929859, 0.714846570552915, -0.230377813308895]
        },
        'sine': { // Custom Sine Basis for STFT-like effects
            // This is a placeholder; a true sine transform is different.
            // We'll simulate with a simple high/low pass filter.
            dec: [0.5, 0.5, 0.5, 0.5],
            rec: [0.5, 0.5, 0.5, 0.5]
        }
      };

      function getWaveletFilters(name) {
          const basis = waveletBases[name];
          if (!basis) throw new Error('Unknown wavelet: ' + name);
          
          const h = basis.dec; // Low-pass decomposition
          const g = h.slice().reverse().map((v, i) => i % 2 === 0 ? -v : v); // High-pass decomposition
          const h_rec = basis.rec; // Low-pass reconstruction
          const g_rec = h_rec.slice().reverse().map((v, i) => i % 2 === 1 ? -v : v); // High-pass reconstruction
          
          return { h, g, h_rec, g_rec };
      }

      function convolve(signal, filter) {
          const len = signal.length;
          const fLen = filter.length;
          const output = new Float32Array(len);
          for (let i = 0; i < len; i++) {
              let sum = 0;
              for (let j = 0; j < fLen; j++) {
                  // periodic boundary extension
                  const index = (i + j) % len;
                  sum += signal[index] * filter[j];
              }
              output[i] = sum;
          }
          return output;
      }
      
      function downsample(signal) {
          const out = new Float32Array(signal.length / 2);
          for(let i=0; i<out.length; i++) {
              out[i] = signal[i*2];
          }
          return out;
      }
      
      function upsample(signal, len) {
          const out = new Float32Array(len);
          for(let i=0; i<signal.length; i++) {
              out[i*2] = signal[i];
          }
          return out;
      }

      function dwt(signal, basisName = 'haar') {
          const { h, g } = getWaveletFilters(basisName);
          let coeffs = [];
          let approx = signal;
          
          while (approx.length >= h.length) {
              const approx_conv = convolve(approx, h);
              const detail_conv = convolve(approx, g);
              
              const approx_down = downsample(approx_conv);
              const detail_down = downsample(detail_conv);
              
              coeffs.unshift(detail_down);
              approx = approx_down;
          }
          coeffs.unshift(approx);
          return coeffs;
      }

      function idwt(coeffs, basisName = 'haar') {
          const { h_rec, g_rec } = getWaveletFilters(basisName);
          let approx = coeffs[0];
          
          for (let i = 1; i < coeffs.length; i++) {
              const detail = coeffs[i];
              const targetLen = approx.length + detail.length;
              
              const approx_up = upsample(approx, targetLen);
              const detail_up = upsample(detail, targetLen);
              
              const approx_conv = convolve(approx_up, h_rec);
              const detail_conv = convolve(detail_up, g_rec);
              
              const reconstructed = new Float32Array(targetLen);
              for (let j = 0; j < targetLen; j++) {
                  reconstructed[j] = approx_conv[j] + detail_conv[j];
              }
              approx = reconstructed;
          }
          return approx;
      }

      function padToPowerOfTwo(signal) {
          const L = signal.length;
          const targetL = Math.pow(2, Math.ceil(Math.log2(L)));
          if (L === targetL) return signal;
          
          const padded = new Float32Array(targetL);
          padded.set(signal);
          return padded;
      }

      // Wavelet processor wrapper
      function applyWaveletBend(processorFn, opts, region) {
        const originalLength = region.length;
        const paddedSignal = padToPowerOfTwo(region);
        
        let coeffs = dwt(paddedSignal, opts.basis);
        coeffs = processorFn(coeffs, opts);
        let processedSignal = idwt(coeffs, opts.basis);
        
        // Truncate back to original length
        return processedSignal.slice(0, originalLength);
      }
      
      const waveletBasisOptions = [
          { value: 'haar', label: 'Haar (Blocky)'},
          { value: 'db4', label: 'Daubechies-4'},
          { value: 'db8', label: 'Daubechies-8'},
          { value: 'sine', label: 'Sine-Basis (Tonal)'}
      ];

      /* ======= WAVELET IMPLEMENTATION END ======= */

      /* ======= Processors ======= */
      bitcrushBtn.onclick = () =>
        showModal({
          title: "Bitcrush",
          controls: {
            bits: {
              label: "Bit Depth",
              min: 1,
              max: 16,
              step: 1,
              defaultValue: 8,
            },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const o = new Float32Array(r.length),
                  s = Math.pow(0.5, opts.bits - 1);
                for (let i = 0; i < r.length; i++)
                  o[i] = s * Math.floor(r[i] / s + 0.5);
                return o;
              },
              { label: "BitCrushing..." }
            ),
        });
      foldBtn.onclick = () =>
        showModal({
          title: "Wavefolder",
          controls: {
            gain: { label: "Gain", min: 1, max: 50, step: 1, defaultValue: 10 },
            folds: {
              label: "Folds",
              min: 1,
              max: 20,
              step: 1,
              defaultValue: 5,
            },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const o = new Float32Array(r.length);
                for (let i = 0; i < r.length; i++) {
                  let v = r[i] * opts.gain;
                  for (let f = 0; f < opts.folds; f++)
                    v = Math.abs(Math.abs(v) - 1);
                  o[i] = (v * 2 - 1) / opts.gain;
                }
                return o;
              },
              { label: "Folding..." }
            ),
        });
      shiftBtn.onclick = () =>
        applybend(
          (r) => {
            const s = Math.floor(parseInt(intensityEl.value || 50) / 10),
              d = new DataView(f32ToInt16Buffer(r));
            for (let i = 0; i < d.byteLength; i += 2) {
              let v = d.getInt16(i, !0);
              d.setInt16(i, Math.max(-32768, Math.min(32767, v << s)), !0);
            }
            return int16BufferToF32(d.buffer);
          },
          { label: "Shifting..." }
        );
      invertBtn.onclick = () =>
        applybend(
          (r) => {
            const c = parseInt(intensityEl.value || 50) / 100,
              a = new Uint8Array(f32ToInt16Buffer(r));
            for (let i = 0; i < a.length; i++)
              if (Math.random() < c) a[i] = ~a[i] & 255;
            return int16BufferToF32(a.buffer);
          },
          { label: "Inverting..." }
        );
      randomBtn.onclick = () =>
        applybend(
          (r) => {
            const c = parseInt(intensityEl.value || 50) / 100,
              d = new DataView(f32ToInt16Buffer(r));
            for (let i = 0; i < d.byteLength; i++)
              if (Math.random() < c)
                d.setUint8(i, Math.floor(Math.random() * 256));
            return int16BufferToF32(d.buffer);
          },
          { label: "Randomizing..." }
        );
      corruptBtn.onclick = () =>
        applybend(
          (r) => {
            const n = Math.floor(
                ((r.length * 2) / 100) * parseInt(intensityEl.value || 50)
              ),
              d = new DataView(f32ToInt16Buffer(r));
            for (let i = 0; i < n; i++)
              d.setUint8(
                Math.floor(Math.random() * d.byteLength),
                Math.floor(Math.random() * 256)
              );
            return int16BufferToF32(d.buffer);
          },
          { label: "Corrupting..." }
        );
      granularBtn.onclick = () => {
        const c = Math.max(4, parseInt(chunkSizeEl.value) || 512);
        applybend(
          (r) => {
            const o = new Float32Array(r.length),
              cs = Math.floor(r.length / c);
            if (cs < 1) return r.slice();
            for (let i = 0; i < r.length; i++) {
              const g = Math.floor(Math.random() * cs) * c;
              o[i] = r[Math.min(g + (i % c), r.length - 1)];
            }
            return o;
          },
          { label: "Granularizing..." }
        );
      };
      stutterBtn.onclick = () => {
        const c = Math.max(4, parseInt(chunkSizeEl.value) || 512);
        applybend(
          (r) => {
            const o = new Float32Array(r.length);
            for (let i = 0; i < r.length; i++) {
              const s = Math.floor(i / c) * c;
              o[i] = r[Math.min(s, r.length - 1)];
            }
            return o;
          },
          { label: "Stuttering..." }
        );
      };
      reverseBtn.onclick = () =>
        applybend(
          (r) => {
            const o = r.slice();
            o.reverse();
            return o;
          },
          { label: "Reversing..." }
        );
      scrambleBtn.onclick = () =>
        applybend(
          (r) => {
            const c = Math.max(4, parseInt(chunkSizeEl.value) || 512),
              o = r.slice();
            for (let i = 0; i < o.length; i += c) {
              const s = o.slice(i, Math.min(i + c, o.length));
              for (let j = s.length - 1; j > 0; j--) {
                const k = Math.floor(Math.random() * (j + 1));
                [s[j], s[k]] = [s[k], s[j]];
              }
              o.set(s, i);
            }
            return o;
          },
          { label: "Scrambling..." }
        );
      ringBtn.onclick = () =>
        showModal({
          title: "Ring Modulator",
          controls: {
            freq: {
              label: "Freq (Hz)",
              min: 20,
              max: 5e3,
              step: 1,
              defaultValue: 440,
            },
            modDepth: {
              label: "Mod Depth",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
            modRate: {
              label: "Mod Rate (Hz)",
              min: 0.1,
              max: 20,
              step: 0.1,
              defaultValue: 2,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const o = new Float32Array(r.length);
                for (let i = 0; i < r.length; i++) {
                  const t = i / sr,
                    m =
                      Math.sin(2 * Math.PI * opts.modRate * t) * opts.modDepth,
                    cF = opts.freq * (1 + m * 0.5);
                  o[i] = r[i] * Math.sin(2 * Math.PI * cF * t);
                }
                return o;
              },
              { label: "Ring Mod..." }
            ),
        });
      warpBtn.onclick = () =>
        showModal({
          title: "Bit Warp",
          controls: {
            warp: {
              label: "Warp",
              min: 1,
              max: 20,
              step: 0.1,
              defaultValue: 10,
            },
            mix: { label: "Mix", min: 0, max: 1, step: 0.01, defaultValue: 1 },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const o = new Float32Array(r.length);
                for (let i = 0; i < r.length; i++) {
                  const x = r[i],
                    s = Math.sign(x) * (1 - Math.exp(-Math.abs(x) * opts.warp)),
                    w = Math.tanh(s * (1 + opts.warp / 10));
                  o[i] = x * (1 - opts.mix) + w * opts.mix;
                }
                return o;
              },
              { label: "Bit Warping..." }
            ),
        });
      smearBtn.onclick = () =>
        showModal({
          title: "Spectral Smear",
          controls: {
            windowSize: {
              label: "Window Size",
              min: 256,
              max: 4096,
              step: 128,
              defaultValue: 1024,
            },
            jitter: {
              label: "Jitter",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
            mix: {
              label: "Mix",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.7,
            },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const l = r.length,
                  wS = opts.windowSize,
                  h = Math.floor(wS / 2),
                  o = new Float32Array(l),
                  w = new Float32Array(wS);
                for (let i = 0; i < wS; i++)
                  w[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (wS - 1)));
                const a = new Float32Array(l),
                  cs = new Float32Array(l);
                for (let p = 0; p < l; p += h) {
                  const b = new Float32Array(wS);
                  for (let i = 0; i < wS; i++)
                    b[i] = r[Math.min(l - 1, p + i)] * w[i];
                  const bs = 8,
                    bSz = Math.floor(wS / bs),
                    bB = new Float32Array(wS);
                  for (let j = 0; j < bs; j++) {
                    const s = j * bSz,
                      e = Math.min(wS, s + bSz),
                      jA = Math.floor(
                        (Math.random() - 0.5) * opts.jitter * bSz
                      );
                    for (let k = s; k < e; k++) {
                      const t = k + jA;
                      if (t >= 0 && t < wS) bB[t] += b[k] * 0.9;
                    }
                  }
                  for (let i = 0; i < wS; i++) {
                    const idx = Math.min(l - 1, p + i);
                    a[idx] += bB[i] * w[i];
                    cs[idx] += w[i] * w[i];
                  }
                }
                for (let i = 0; i < l; i++)
                  o[i] = cs[i] > 1e-6 ? a[i] / cs[i] : r[i];
                for (let i = 0; i < l; i++)
                  o[i] = o[i] * opts.mix + r[i] * (1 - opts.mix);
                return o;
              },
              { label: "Smearing..." }
            ),
        });
      chebyBtn.onclick = () =>
        showModal({
          title: "Chebyshev",
          controls: {
            order: {
              label: "Order",
              min: 2,
              max: 32,
              step: 1,
              defaultValue: 8,
            },
            mix: {
              label: "Mix",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const o = new Float32Array(r.length);
                for (let i = 0; i < r.length; i++) {
                  const x = r[i];
                  let T_p = 1,
                    T_c = x;
                  for (let k = 1; k < opts.order; k++) {
                    let T_n = 2 * x * T_c - T_p;
                    T_p = T_c;
                    T_c = T_n;
                  }
                  o[i] = x * (1 - opts.mix) + T_c * opts.mix;
                }
                return o;
              },
              { label: "Warping..." }
            ),
        });
      combBtn.onclick = () =>
        showModal({
          title: "Feedback Comb",
          controls: {
            freq: {
              label: "Freq (Hz)",
              min: 30,
              max: 4e3,
              step: 1,
              defaultValue: 150,
            },
            feedback: {
              label: "Feedback",
              min: 0.1,
              max: 0.99,
              step: 0.01,
              defaultValue: 0.85,
            },
            mix: {
              label: "Mix",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const dS = Math.floor(sr / opts.freq),
                  o = new Float32Array(r.length);
                for (let i = 0; i < r.length; i++) {
                  const d = o[i - dS] || 0,
                    p = r[i] + opts.feedback * d;
                  o[i] = r[i] * (1 - opts.mix) + p * opts.mix;
                }
                return o;
              },
              { label: "Feedback..." }
            ),
        });
      tapeStopBtn.onclick = () =>
        showModal({
          title: "Tape Stop",
          controls: {
            duration: {
              label: "Duration (s)",
              min: 0.1,
              max: 5,
              step: 0.1,
              defaultValue: 1,
            },
            curve: {
              label: "Curve",
              min: 0.2,
              max: 5,
              step: 0.1,
              defaultValue: 2,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const len = r.length,
                  o = new Float32Array(len),
                  stopSamps = Math.min(len, Math.floor(opts.duration * sr));
                for (let i = 0; i < len; i++) {
                  if (i < stopSamps) {
                    const p = i / stopSamps,
                      pC = Math.pow(p, opts.curve),
                      sIdx = Math.floor(pC * (stopSamps - 1)),
                      vol = 1 - p;
                    o[i] = r[sIdx] * vol;
                  } else {
                    o[i] = 0;
                  }
                }
                return o;
              },
              { label: "Tape Stop..." }
            ),
        });
      melterBtn.onclick = () =>
        showModal({
          title: "Melter",
          controls: {
            chunkSize: {
              label: "Chunk Size",
              min: 4,
              max: 256,
              step: 4,
              defaultValue: 32,
            },
            feedback: {
              label: "Feedback",
              min: 0,
              max: 0.99,
              step: 0.01,
              defaultValue: 0.8,
            },
            mix: {
              label: "Mix",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const o = new Float32Array(r.length);
                let fb = 0;
                for (let i = 0; i < r.length; i++) {
                  const s = r[i];
                  if (i % opts.chunkSize === 0) fb = 0;
                  fb = s * 0.5 + fb * 0.5;
                  o[i] = r[i] * (1 - opts.mix) + fb * opts.mix;
                }
                return o;
              },
              { label: "Melting..." }
            ),
        });
      shredderBtn.onclick = () =>
        showModal({
          title: "Shredder",
          controls: {
            sliceDiv: {
              label: "Slice Divisor",
              min: 4,
              max: 64,
              step: 4,
              defaultValue: 16,
            },
            reps: {
              label: "Repetitions",
              min: 1,
              max: 16,
              step: 1,
              defaultValue: 4,
            },
            chance: {
              label: "Chance",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const o = new Float32Array(r.length),
                  sliceLen = Math.floor(sr / opts.sliceDiv);
                for (let i = 0; i < r.length; i += sliceLen) {
                  if (Math.random() < opts.chance) {
                    const grain = r.slice(
                      i,
                      i + Math.floor(sliceLen / opts.reps)
                    );
                    for (let j = 0; j < sliceLen && i + j < r.length; j++)
                      o[i + j] = grain[j % grain.length];
                  } else {
                    for (let j = 0; j < sliceLen && i + j < r.length; j++)
                      o[i + j] = r[i + j];
                  }
                }
                return o;
              },
              { label: "Shredding..." }
            ),
        });
      bitScrambleBtn.onclick = () =>
        showModal({
          title: "Bit Scramble",
          controls: {
            chunkSize: {
              label: "Chunk Size (bytes)",
              min: 2,
              max: 64,
              step: 2,
              defaultValue: 8,
            },
            intensity: {
              label: "Intensity",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r) => {
                const arr = new Uint8Array(f32ToInt16Buffer(r));
                for (let i = 0; i < arr.length; i += opts.chunkSize) {
                  if (Math.random() < opts.intensity) {
                    const s = arr.slice(i, i + opts.chunkSize);
                    for (let j = s.length - 1; j > 0; j--) {
                      const k = Math.floor(Math.random() * (j + 1));
                      [s[j], s[k]] = [s[k], s[j]];
                    }
                    arr.set(s, i);
                  }
                }
                return int16BufferToF32(arr.buffer);
              },
              { label: "Scrambling Bits..." }
            ),
        });
      filterBtn.onclick = () =>
        showModal({
          title: "Filter",
          controls: {
            type: {
              label: "Type (1=LP,-1=HP)",
              min: -1,
              max: 1,
              step: 2,
              defaultValue: 1,
            },
            freq: {
              label: "Freq (Hz)",
              min: 50,
              max: 15e3,
              step: 10,
              defaultValue: 2e3,
            },
            q: { label: "Q", min: 0.1, max: 30, step: 0.1, defaultValue: 1 },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const o = new Float32Array(r.length),
                  w0 = (2 * Math.PI * opts.freq) / sr,
                  alpha = Math.sin(w0) / (2 * opts.q),
                  cosw0 = Math.cos(w0);
                let b0, b1, b2, a0, a1, a2;
                if (opts.type > 0) {
                  b0 = (1 - cosw0) / 2;
                  b1 = 1 - cosw0;
                  b2 = (1 - cosw0) / 2;
                } else {
                  b0 = (1 + cosw0) / 2;
                  b1 = -(1 + cosw0);
                  b2 = (1 + cosw0) / 2;
                }
                a0 = 1 + alpha;
                a1 = -2 * cosw0;
                a2 = 1 - alpha;
                let x1 = 0,
                  x2 = 0,
                  y1 = 0,
                  y2 = 0;
                for (let i = 0; i < r.length; i++) {
                  const x0 = r[i],
                    y0 =
                      (b0 / a0) * x0 +
                      (b1 / a0) * x1 +
                      (b2 / a0) * x2 -
                      (a1 / a0) * y1 -
                      (a2 / a0) * y2;
                  o[i] = y0;
                  x2 = x1;
                  x1 = x0;
                  y2 = y1;
                  y1 = y0;
                }
                return o;
              },
              { label: "Filtering..." }
            ),
        });
      phaserBtn.onclick = () =>
        showModal({
          title: "Phaser",
          controls: {
            rate: {
              label: "Rate (Hz)",
              min: 0.1,
              max: 10,
              step: 0.1,
              defaultValue: 1,
            },
            depth: {
              label: "Depth",
              min: 0.1,
              max: 1,
              step: 0.01,
              defaultValue: 0.7,
            },
            feedback: {
              label: "Feedback",
              min: 0,
              max: 0.9,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const o = new Float32Array(r.length),
                  s = 4,
                  ap = Array(s)
                    .fill(0)
                    .map(() => ({ z: 0 }));
                let fb = 0;
                for (let i = 0; i < r.length; i++) {
                  const lfo = Math.sin(2 * Math.PI * opts.rate * (i / sr)),
                    d = 0.5 * (1 + lfo) * opts.depth;
                  let y = r[i] + fb * opts.feedback;
                  for (let j = 0; j < s; j++) {
                    const z = ap[j].z;
                    ap[j].z = y * d + z * (1 - d);
                    y = ap[j].z - y * d;
                  }
                  fb = y;
                  o[i] = r[i] * 0.5 + y * 0.5;
                }
                return o;
              },
              { label: "Phasing..." }
            ),
        });
      delayBtn.onclick = () =>
        showModal({
          title: "Delay",
          controls: {
            time: {
              label: "Time (ms)",
              min: 10,
              max: 2e3,
              step: 1,
              defaultValue: 250,
            },
            feedback: {
              label: "Feedback",
              min: 0,
              max: 0.9,
              step: 0.01,
              defaultValue: 0.5,
            },
            mix: {
              label: "Mix",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.5,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const dS = Math.floor((sr * opts.time) / 1e3),
                  o = new Float32Array(r.length + dS);
                o.set(r);
                for (let i = 0; i < o.length; i++) {
                  const d = o[i - dS] || 0;
                  o[i] += d * opts.feedback;
                }
                const f = r.slice();
                for (let i = 0; i < f.length; i++)
                  f[i] = r[i] * (1 - opts.mix) + o[i] * opts.mix;
                return f;
              },
              { label: "Delaying..." }
            ),
        });
      reverbBtn.onclick = () =>
        showModal({
          title: "Reverb",
          controls: {
            roomSize: {
              label: "Room Size",
              min: 0.1,
              max: 0.99,
              step: 0.01,
              defaultValue: 0.7,
            },
            mix: {
              label: "Mix",
              min: 0,
              max: 1,
              step: 0.01,
              defaultValue: 0.4,
            },
          },
          callback: (opts) =>
            applybend(
              (r, { sr }) => {
                const ds = [1613, 2053, 2671, 3121].map((d) =>
                    Math.floor(d * (sr / 44100))
                  ),
                  cs = ds.map((d) => ({
                    buf: new Float32Array(d),
                    idx: 0,
                    fb: opts.roomSize,
                  })),
                  y = new Float32Array(r.length);
                for (let i = 0; i < r.length; i++) {
                  let s = r[i],
                    cb_out = 0;
                  for (const c of cs) {
                    const d = c.buf[c.idx];
                    c.buf[c.idx] = s + d * c.fb;
                    c.idx = (c.idx + 1) % c.buf.length;
                    cb_out += d;
                  }
                  y[i] = cb_out / cs.length;
                }
                for (let i = 0; i < r.length; i++)
                  y[i] = r[i] * (1 - opts.mix) + y[i] * opts.mix;
                return y;
              },
              { label: "Reverb..." }
            ),
        });

      /* =========== NEW WAVELET PROCESSORS =========== */
      waveletChaosBtn.onclick = () => showModal({
          title: "Wavelet Chaos Engine",
          controls: {
              basis: { type: 'select', label: 'Wavelet Basis', options: waveletBasisOptions },
              dropout: { label: "Dropout", min: 0, max: 1, step: 0.01, defaultValue: 0.1 },
              phase: { label: "Phase Corruption", min: 0, max: 1, step: 0.01, defaultValue: 0.2 },
              shuffle: { label: "Packet Shuffle", min: 0, max: 1, step: 0.01, defaultValue: 0.5 }
          },
          callback: opts => applybend(r => applyWaveletBend(
              (coeffs, o) => {
                  // Packet Shuffling
                  if (Math.random() < o.shuffle) {
                      for (let i = coeffs.length - 2; i > 0; i--) {
                          const j = 1 + Math.floor(Math.random() * (coeffs.length - 2));
                          [coeffs[i], coeffs[j]] = [coeffs[j], coeffs[i]];
                      }
                  }
                  // Dropout & Phase Corruption
                  for (let i = 1; i < coeffs.length; i++) { // Skip approximation coeffs
                      for (let j = 0; j < coeffs[i].length; j++) {
                          if (Math.random() < o.dropout) coeffs[i][j] = 0;
                          if (Math.random() < o.phase) coeffs[i][j] *= -1;
                      }
                  }
                  return coeffs;
              }, opts, r), { label: "Injecting Chaos..." })
      });

      scaleCorruptorBtn.onclick = () => showModal({
          title: "Scale-Subband Corruptor",
          controls: {
              basis: { type: 'select', label: 'Wavelet Basis', options: waveletBasisOptions },
              dropout: { label: "Subband Dropout", min: 0, max: 1, step: 0.01, defaultValue: 0.1 },
              quantize: { label: "Quantize Bits", min: 1, max: 16, step: 1, defaultValue: 6 },
              jitter: { label: "Scale Jitter", min: 0, max: 1, step: 0.01, defaultValue: 0.2 },
          },
          callback: opts => applybend(r => applyWaveletBend(
              (coeffs, o) => {
                  // Subband dropout & Quantization
                  for (let i = 1; i < coeffs.length; i++) {
                      if (Math.random() < o.dropout) {
                          coeffs[i].fill(0);
                      } else {
                          const s = Math.pow(0.5, o.quantize - 1);
                          for (let j = 0; j < coeffs[i].length; j++) {
                              coeffs[i][j] = s * Math.floor(coeffs[i][j] / s + 0.5);
                          }
                      }
                  }
                  // Scale Jitter
                  for (let i = 1; i < coeffs.length; i++) {
                      if (Math.random() < o.jitter) {
                           const shift = Math.floor((Math.random() - 0.5) * coeffs[i].length * 0.2);
                           const buffer = coeffs[i].slice();
                           for(let j=0; j<buffer.length; j++) {
                               coeffs[i][j] = buffer[(j + shift + buffer.length) % buffer.length];
                           }
                      }
                  }
                  return coeffs;
              }, opts, r), { label: "Corrupting Scales..." })
      });

      waveletTreeDisruptorBtn.onclick = () => showModal({
          title: "Wavelet Tree Disruptor",
          controls: {
              basis: { type: 'select', label: 'Wavelet Basis', options: waveletBasisOptions },
              prune: { label: "Pruning Threshold", min: 0, max: 1, step: 0.01, defaultValue: 0.05 },
              smear: { label: "Coefficient Smear", min: 0, max: 1, step: 0.01, defaultValue: 0.5 }
          },
          callback: opts => applybend(r => applyWaveletBend(
              (coeffs, o) => {
                  // Pruning
                  for (let i = 1; i < coeffs.length; i++) {
                      for (let j = 0; j < coeffs[i].length; j++) {
                          if (Math.abs(coeffs[i][j]) < o.prune) {
                              coeffs[i][j] = 0;
                          }
                      }
                  }
                  // Smearing
                  for (let i = 1; i < coeffs.length; i++) {
                      if (Math.random() < o.smear) {
                           for (let j = 1; j < coeffs[i].length; j++) {
                              coeffs[i][j] = (coeffs[i][j] + coeffs[i][j-1]) * 0.5;
                           }
                      }
                  }
                  return coeffs;
              }, opts, r), { label: "Disrupting Tree..." })
      });

      entropyGlitchBtn.onclick = () => showModal({
          title: "Entropy Glitch Injector",
          controls: {
              basis: { type: 'select', label: 'Wavelet Basis', options: waveletBasisOptions },
              flip: { label: "Coefficient Flip", min: 0, max: 1, step: 0.01, defaultValue: 0.1 },
              entropy: { label: "Entropy Injection", min: 0, max: 1, step: 0.01, defaultValue: 0.05 }
          },
          callback: opts => applybend(r => applyWaveletBend(
              (coeffs, o) => {
                  for (let i = 1; i < coeffs.length; i++) {
                      for (let j = 0; j < coeffs[i].length; j++) {
                          // Flipping
                          if (Math.random() < o.flip) coeffs[i][j] *= -1;
                          // Entropy Injection
                          if (Math.random() < o.entropy) {
                              coeffs[i][j] += (Math.random() - 0.5) * o.entropy;
                          }
                      }
                  }
                  return coeffs;
              }, opts, r), { label: "Injecting Entropy..." })
      });

      /* ======= Selection & Playback ======= */
      duplicateBtn.onclick = () => duplicateLoop();
      deleteBtn.onclick = () => deleteLoop();

      async function duplicateLoop() {
        if (!current) {
          setStatus("Load a file first", 800);
          return;
        }
        if (!audioCtx) initAudioContext();
        const hasLoop = loopEnd > loopStart && loopEnd - loopStart > 0.02;
        if (!hasLoop) {
          setStatus("Select a region to duplicate", 1000);
          return;
        }
        if (playing) stopPlaybackSilent();

        await saveState();
        const sr = audioCtx.sampleRate;
        const startSample = Math.floor(loopStart * sr);
        const endSample = Math.floor(loopEnd * sr);

        const loopData = current.slice(startSample, endSample);
        const partAfter = current.slice(endSample);

        const newBuffer = new Float32Array(current.length + loopData.length);
        newBuffer.set(current.slice(0, endSample), 0);
        newBuffer.set(loopData, endSample);
        newBuffer.set(partAfter, endSample + loopData.length);

        current = newBuffer;

        // Highlight the newly inserted duplicate region as the current loop
        const newStartSample = endSample;
        const newEndSample = endSample + loopData.length;
        loopStart = newStartSample / sr;
        loopEnd = newEndSample / sr;

        updateUI();
        setStatus("Selection duplicated", 900);
        await saveAudioToDB(current);

        // Start playback of the duplicated region so it's obvious on the UI
        try {
          await startPlayback(loopStart);
        } catch (e) {
          console.warn("Could not start playback after duplicate:", e);
        }
      }

      async function deleteLoop() {
        if (!current) {
          setStatus("Load a file first", 800);
          return;
        }
        if (!audioCtx) initAudioContext();
        const hasLoop = loopEnd > loopStart && loopEnd - loopStart > 0.02;
        if (!hasLoop) {
          setStatus("Select a region to delete", 1000);
          return;
        }
        if (playing) stopPlaybackSilent();

        await saveState();
        const sr = audioCtx.sampleRate;
        const startSample = Math.floor(loopStart * sr);
        const endSample = Math.floor(loopEnd * sr);

        const selectionLength = endSample - startSample;
        const newLength = current.length - selectionLength;
        if (newLength <= 0) {
          current = new Float32Array(0);
        } else {
          const newBuffer = new Float32Array(newLength);
          newBuffer.set(current.slice(0, startSample), 0);
          newBuffer.set(current.slice(endSample), startSample);
          current = newBuffer;
        }

        loopStart = 0;
        loopEnd = 0;
        updateUI();
        setStatus("Selection deleted", 900);
        await saveAudioToDB(current);
      }

      function stopPlaybackSilent() {
        if (playSource) {
          try {
            playSource.stop();
          } catch (e) {}
          try {
            playSource.disconnect();
          } catch (e) {}
          playSource = null;
        }
        playing = false;
        playBtn.textContent = "Play";
      }

      function stopPlayback() {
        stopPlaybackSilent();
        setStatus("Stopped", 600);
      }

      async function startPlayback(at = 0) {
        stopPlaybackSilent();
        if (!current) return setStatus("No file", 800);
        if (!audioCtx) initAudioContext();
        if (audioCtx.state === "suspended") await audioCtx.resume();

        const buf = audioCtx.createBuffer(
          1,
          current.length,
          audioCtx.sampleRate
        );
        buf.getChannelData(0).set(current);
        const src = audioCtx.createBufferSource();
        src.buffer = buf;
        src.connect(audioCtx.destination);

        if (loopEnd > loopStart && loopEnd - loopStart > 0.02) {
          src.loop = true;
          src.loopStart = loopStart;
          src.loopEnd = loopEnd;
          playLoopActive = true;
          src.start(0, at >= loopEnd ? loopStart : at);
        } else {
          src.loop = false;
          playLoopActive = false;
          src.start(0, at);
        }

        playSource = src;
        playing = true;
        playStartTime = audioCtx.currentTime;
        playOffset = at;
        playBtn.textContent = "Playing...";
        src.onended = () => {
          if (src === playSource && !playLoopActive) {
            playing = false;
            playBtn.textContent = "Play";
            setStatus("Playback ended", 800);
          }
        };
      }
      playBtn.onclick = async () => {
        if (!audioCtx) initAudioContext();
        if (playing) {
          stopPlayback();
          return;
        }
        await startPlayback(lastPlayheadPos || 0);
      };
      stopBtn.onclick = stopPlayback;

      /* ======= Overlay Interaction & Drawing ======= */
      let isDragging = false,
        dragStartX = 0,
        dragCurrentX = 0,
        pointerDown = false,
        isDraggingLoopEdge = false,
        draggingEdge = null;
      let lastPlayheadPos = 0;
      function setupOverlayInteraction() {
        overlay.addEventListener("pointerdown", (ev) => {
          if (!current) return;
          overlay.setPointerCapture(ev.pointerId);
          pointerDown = true;
          const x = ev.clientX - overlay.getBoundingClientRect().left;
          dragStartX = x;
          dragCurrentX = x;
          isDragging = true;
          const [sx, ex] = loopPixels();
          const edgeTolerance = 12;
          if (sx !== null && Math.abs(x - sx) < edgeTolerance) {
            isDraggingLoopEdge = true;
            draggingEdge = "start";
          } else if (ex !== null && Math.abs(x - ex) < edgeTolerance) {
            isDraggingLoopEdge = true;
            draggingEdge = "end";
          } else isDraggingLoopEdge = false;
        });

        overlay.addEventListener("pointermove", (ev) => {
          const rect = overlay.getBoundingClientRect();
          const x = Math.max(0, Math.min(rect.width, ev.clientX - rect.left));
          if (!pointerDown) {
            lastPlayheadPos = xToTime(x);
            drawOverlay();
            return;
          }
          dragCurrentX = x;
          if (isDragging && isDraggingLoopEdge) {
            const t = xToTime(x);
            if (draggingEdge === "start") {
              loopStart = Math.max(0, Math.min(loopEnd - 0.02, t));
            } else {
              loopEnd = Math.min(
                durationSeconds(),
                Math.max(loopStart + 0.02, t)
              );
            }
          }
          drawOverlay();
        });

        overlay.addEventListener("pointerup", (ev) => {
          if (!pointerDown) return;
          pointerDown = false;
          overlay.releasePointerCapture(ev.pointerId);

          const a = dragStartX,
            b = dragCurrentX;
          const smallMove = Math.abs(b - a) < 6;

          if (isDraggingLoopEdge) {
            // finalise loop edges; do NOT auto-start playback unless we were already looping
            if (loopEnd - loopStart < 0.02)
              loopEnd = Math.min(durationSeconds(), loopStart + 0.02);
            // if user was playing a loop, restart it with the new boundaries so audio stays in sync
            if (playing && playLoopActive) {
              startPlayback(loopStart);
            }
          } else if (smallMove) {
            // single click -> move playhead only (no auto-play)
            const t = xToTime(b);
            lastPlayheadPos = t;
            // do not call startPlayback here; user can press Play or Space to start
          } else {
            // selection drag -> set loop but do not auto-play
            const t1 = xToTime(a),
              t2 = xToTime(b);
            loopStart = Math.min(t1, t2);
            loopEnd = Math.max(t1, t2);
            if (loopEnd - loopStart < 0.02)
              loopEnd = Math.min(durationSeconds(), loopStart + 0.02);
            // if already playing a loop, restart so playback follows new loop
            if (playing && playLoopActive) startPlayback(loopStart);
          }

          isDragging = false;
          isDraggingLoopEdge = false;
          draggingEdge = null;
          drawOverlay();
        });

        overlay.addEventListener("dblclick", () => {
          // double-click clears loop selection; do not change playback state
          loopStart = 0;
          loopEnd = 0;
          drawOverlay();
        });
      }
      function xToTime(x) {
        if (!audioCtx) return 0;
        const rect = overlay.getBoundingClientRect();
        return (
          Math.max(0, Math.min(1, x / (rect.width || 1))) * durationSeconds()
        );
      }
      function timeToX(time) {
        const rect = overlay.getBoundingClientRect();
        return (time / Math.max(1e-4, durationSeconds())) * (rect.width || 1);
      }
      function durationSeconds() {
        if (!audioCtx) return 0;
        return current ? current.length / audioCtx.sampleRate : 0;
      }
      function loopPixels() {
        if (!current || loopEnd <= loopStart) return [null, null];
        return [timeToX(loopStart), timeToX(loopEnd)];
      }

      function drawOverlay() {
        const w = octx.canvas.width / devicePixelRatio,
          h = octx.canvas.height / devicePixelRatio;
        octx.clearRect(0, 0, w, h);
        if (loopEnd > loopStart && current) {
          const sx = timeToX(loopStart),
            ex = timeToX(loopEnd);
          octx.save();
          octx.fillStyle = hexToRGBA(accent, 0.08);
          octx.fillRect(sx, 0, ex - sx, h);
          octx.lineWidth = 2;
          octx.strokeStyle = accent;
          octx.shadowColor = accent;
          octx.shadowBlur = 12;
          octx.strokeRect(sx + 1, 1, ex - sx - 2, h - 2);
          octx.restore();
        }
        if (isDragging && !isDraggingLoopEdge && pointerDown) {
          const sx = Math.min(dragStartX, dragCurrentX),
            ex = Math.max(dragStartX, dragCurrentX);
          octx.save();
          octx.fillStyle = hexToRGBA(accent, 0.05);
          octx.fillRect(sx, 0, ex - sx, h);
          octx.lineWidth = 1.6;
          octx.strokeStyle = accent;
          octx.setLineDash([6, 6]);
          octx.strokeRect(sx + 1, 1, ex - sx - 2, h - 2);
          octx.restore();
        }
        let playPos = lastPlayheadPos;
        if (playing && audioCtx) {
          const elapsed = audioCtx.currentTime - playStartTime;
          let posSec = playOffset + elapsed;
          if (playLoopActive && loopEnd - loopStart > 0) {
            posSec = loopStart + ((posSec - loopStart) % (loopEnd - loopStart));
          } else {
            posSec = posSec % Math.max(1e-4, durationSeconds());
          }
          playPos = posSec;
          lastPlayheadPos = posSec;
        }
        if (current) {
          const x = timeToX(playPos);
          octx.save();
          octx.strokeStyle = "#fff";
          octx.lineWidth = 1;
          octx.globalAlpha = 0.95;
          octx.beginPath();
          octx.moveTo(x, 0);
          octx.lineTo(x, h);
          octx.stroke();
          octx.restore();
        }
      }
      function hexToRGBA(hex, a = 1) {
        const h = hex.replace("#", ""),
          r = parseInt(h.substring(0, 2), 16),
          g = parseInt(h.substring(2, 4), 16),
          b = parseInt(h.substring(4, 6), 16);
        return `rgba(${r},${g},${b},${a})`;
      }
      function drawWaveform() {
        const w = ctx.canvas.width / devicePixelRatio,
          h = ctx.canvas.height / devicePixelRatio;
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, w, h);
        if (!current) return;
        ctx.fillStyle = accent;
        const step = Math.ceil(current.length / w);
        for (let x = 0; x < w; x++) {
          const i = x * step;
          let min = 1,
            max = -1;
          for (let j = 0; j < step && i + j < current.length; j++) {
            const v = current[i + j];
            if (v < min) min = v;
            if (v > max) max = v;
          }
          const y1 = ((max + 1) / 2) * h,
            y2 = ((min + 1) / 2) * h;
          ctx.fillRect(x, y1, 1, Math.max(1, y2 - y1));
        }
      }
      let lastDrawTime = 0;
      function drawLoop(ts) {
        if (!lastDrawTime || ts - lastDrawTime > 16) {
          drawWaveform();
          drawOverlay();
          lastDrawTime = ts;
        }
        requestAnimationFrame(drawLoop);
      }

      /* ======= Keyboard & Export ======= */
      document.addEventListener("keydown", async (e) => {
        // If a modal is open, map keys to modal actions:
        // Space => Commit, Backspace => Cancel, Escape => Close, Enter => Commit
        if (modalOverlay.classList.contains("show")) {
          // prevent accidental scrolling / default behavior
          if (e.code === "Space" || e.key === " ") {
            e.preventDefault();
            modalCommit.click();
            return;
          }
          if (e.key === "Backspace") {
            e.preventDefault();
            modalCancel.click();
            return;
          }
          if (e.key === "Escape") {
            e.preventDefault();
            hideModal();
            return;
          }
          if (e.key === "Enter" || e.code === "NumpadEnter") {
            e.preventDefault();
            modalCommit.click();
            return;
          }
          return;
        }

        const cmd = e.metaKey || e.ctrlKey;

        // Quick open/close processors popup with "P" (ignore when typing in inputs)
        if (e.key && e.key.toLowerCase() === "p" && !cmd && !e.altKey) {
          const active = document.activeElement;
          const inField =
            active &&
            (active.tagName === "INPUT" ||
              active.tagName === "TEXTAREA" ||
              active.tagName === "SELECT" ||
              active.isContentEditable);
          if (!inField) {
            const menu = document.getElementById("procMenu"),
              btn = document.getElementById("processorsBtn");
            if (menu) {
              e.preventDefault();
              const isShown = menu.classList.contains("show");
              if (isShown) {
                menu.classList.remove("show");
                menu.setAttribute("aria-hidden", "true");
                if (btn) btn.focus();
              } else {
                menu.classList.add("show");
                menu.setAttribute("aria-hidden", "false");
                // focus first processor button for keyboard navigation
                const first = menu.querySelector(".proc-btn");
                if (first) first.focus();
              }
            } else if (btn) {
              // fallback: toggle via button
              e.preventDefault();
              btn.click();
            }
            return;
          }
        }

        if (e.code === "Space") {
          e.preventDefault();
          playBtn.click();
        }
        if (cmd && e.key.toLowerCase() === "z") {
          e.preventDefault();
          undoBtn.click();
        }
        if (cmd && e.key.toLowerCase() === "y") {
          e.preventDefault();
          redoBtn.click();
        }
        if (cmd && e.key.toLowerCase() === "s") {
          e.preventDefault();
          exportBtn.click();
        }
        if (cmd && e.key.toLowerCase() === "d") {
          e.preventDefault();
          duplicateLoop();
        }
        if (cmd && e.key.toLowerCase() === "r") {
            e.preventDefault();
            reverseBtn.click();
        }
        if (e.key === "ArrowUp") {
            e.preventDefault();
            pitchTimeShift(1.0594635); // up one semitone
        }
        if (e.key === "ArrowDown") {
            e.preventDefault();
            pitchTimeShift(1 / 1.0594635); // down one semitone
        }
        if (
          (e.key === "Backspace" || e.key === "Delete") &&
          loopEnd > loopStart
        ) {
          e.preventDefault();
          deleteLoop();
        }
      });
      
      async function pitchTimeShift(rate) {
        if (!current) {
            setStatus("Load a file first", 800);
            return;
        }
        if (!audioCtx) initAudioContext();
        const hasLoop = loopEnd > loopStart && loopEnd - loopStart > 0.02;
        if (!hasLoop) {
            setStatus("Select a region to pitch/time shift", 1000);
            return;
        }
        if (playing) stopPlaybackSilent();

        await saveState();

        const sr = audioCtx.sampleRate;
        const startSample = Math.floor(loopStart * sr);
        const endSample = Math.floor(loopEnd * sr);
        const loopData = current.slice(startSample, endSample);

        const newLoopLength = Math.floor(loopData.length / rate);
        const newLoopData = new Float32Array(newLoopLength);

        for (let i = 0; i < newLoopLength; i++) {
            const oldIndex = i * rate;
            const index1 = Math.floor(oldIndex);
            const index2 = Math.min(loopData.length - 1, index1 + 1);
            const fraction = oldIndex - index1;
            newLoopData[i] = loopData[index1] * (1 - fraction) + loopData[index2] * fraction;
        }

        const partAfter = current.slice(endSample);
        const newBuffer = new Float32Array(startSample + newLoopLength + partAfter.length);
        newBuffer.set(current.slice(0, startSample), 0);
        newBuffer.set(newLoopData, startSample);
        newBuffer.set(partAfter, startSample + newLoopLength);

        current = newBuffer;

        const oldLoopDuration = loopEnd - loopStart;
        const newLoopDuration = oldLoopDuration / rate;
        loopEnd = loopStart + newLoopDuration;

        updateUI();
        setStatus("Pitch/Time Shifted", 900);
        await saveAudioToDB(current);
    }

      function writeWAV(arr, sr) {
        const buf = new ArrayBuffer(44 + arr.length * 2),
          view = new DataView(buf);
        const writeS = (o, s) => {
          for (let i = 0; i < s.length; i++)
            view.setUint8(o + i, s.charCodeAt(i));
        };
        writeS(0, "RIFF");
        view.setUint32(4, 36 + arr.length * 2, !0);
        writeS(8, "WAVE");
        writeS(12, "fmt ");
        view.setUint32(16, 16, !0);
        view.setUint16(20, 1, !0);
        view.setUint16(22, 1, !0);
        view.setUint32(24, sr, !0);
        view.setUint32(28, sr * 2, !0);
        view.setUint16(32, 2, !0);
        view.setUint16(34, 16, !0);
        writeS(36, "data");
        view.setUint32(40, arr.length * 2, !0);
        for (let i = 0; i < arr.length; i++) {
          let s = Math.max(-1, Math.min(1, arr[i]));
          view.setInt16(44 + i * 2, s < 0 ? s * 32768 : s * 32767, !0);
        }
        return new Blob([view], { type: "audio/wav" });
      }
      exportBtn.onclick = async () => {
        if (!current) return setStatus("Load a file first", 800);
        if (!audioCtx) initAudioContext();
        glitchProgressStart("Exporting...", 600);
        setTimeout(() => {
          try {
            const wav = writeWAV(current, audioCtx.sampleRate);
            const url = URL.createObjectURL(wav);
            const a = document.createElement("a");
            a.href = url;
            a.download = "databend_export_" + Date.now() + ".wav";
            a.click();
            URL.revokeObjectURL(url);
            setStatus("Exported", 1000);
          } catch (e) {
            console.error(e);
            setStatus("Export failed", 1200);
          }
        }, 250);
      };

      /* ======= Final UI Update ======= */
      function updateUI() {
        if (!current || !audioCtx) {
          durationEl.textContent = "0.00s";
          fileInfoEl.textContent = "No file loaded";
          return;
        }
        const dur = durationSeconds();
        durationEl.textContent = (dur > 0 ? dur.toFixed(2) : "0.00") + "s";
        fileInfoEl.textContent = `${(current.length / 1000).toFixed(
          0
        )}k samples @ ${audioCtx.sampleRate}Hz`;
      }
      

      /* ======= Processors popup setup ======= */
      function setupProcessorsPopup() {
        const btn = document.getElementById("processorsBtn");
        const menu = document.getElementById("procMenu");
        const close = document.getElementById("procClose");
        if (!menu) return; // menu must exist

        function open() {
          menu.classList.add("show");
          menu.setAttribute("aria-hidden", "false");
          // focus first actionable button for keyboard users
          const first = menu.querySelector(".proc-btn");
          if (first) first.focus();
        }
        function hide() {
          menu.classList.remove("show");
          menu.setAttribute("aria-hidden", "true");
          if (btn) btn.focus();
        }

        // optional header button toggler
        if (btn) {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (menu.classList.contains("show")) hide();
            else open();
          });
        }

        // close button inside menu
        if (close) close.addEventListener("click", hide);

        // delegate clicks to hidden original buttons (processor actions)
        menu.addEventListener("click", (e) => {
          const t = e.target.closest("[data-target]");
          if (!t) return;
          const id = t.getAttribute("data-target");
          const orig = document.getElementById(id);
          hide();
          if (orig) orig.click();
        });

        // close on outside click — robust even if btn is missing
        document.addEventListener("click", (e) => {
          if (!menu.classList.contains("show")) return;
          // if click is outside the menu and not on the processors button, close
          const clickedInsideMenu = menu.contains(e.target);
          const clickedOnBtn =
            btn && (e.target === btn || btn.contains(e.target));
          if (!clickedInsideMenu && !clickedOnBtn) hide();
        });

        // Escape closes the popup
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && menu.classList.contains("show")) {
            e.preventDefault();
            hide();
          }
        });
      }
      init();
    </script>
  </body>
</html>